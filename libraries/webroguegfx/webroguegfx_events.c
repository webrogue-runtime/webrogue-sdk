// GENERATED BY webrogue-event-apigen. DO NOT EDIT MANUALLY
// clang-format off
#include "webroguegfx.h"
#include <stdlib.h>

#define WEBROGUE_MAX_ENCODED_EVENT_SIZE 20

__attribute__((import_name("poll")))
__attribute__((import_module("webrogue_gfx")))
void imported_webrogue_gfx_poll(uint32_t* out_len);

__attribute__((import_name("poll_read")))
__attribute__((import_module("webrogue_gfx")))
void imported_webrogue_gfx_poll_read(void *buf);

#define BUF_SIZE(LEN) if(available < LEN) {\
    buffer_consumed = buffer_used_size;\
    result.type = WEBROGUE_EVENT_TYPE_INVALID;\
    return result;\
} buffer_consumed += LEN;
#define GET(TYPE, OFFSET) *((TYPE*)(current_pointer + OFFSET));

webrogue_event webroguegfx_poll() {
    webrogue_event result;
    static void* buffer_data = NULL;
    if(!buffer_data) {
        buffer_data = malloc(WEBROGUE_MAX_ENCODED_EVENT_SIZE);
    }
    static uint32_t buffer_max_size = WEBROGUE_MAX_ENCODED_EVENT_SIZE;
    static uint32_t buffer_used_size = 0;
    static uint32_t buffer_consumed = 0;
    uint32_t available = buffer_used_size - buffer_consumed;
    if(available == 0) {
        uint32_t new_size;
        imported_webrogue_gfx_poll(&new_size);
        if(new_size > buffer_max_size) {
            free(buffer_data);
            buffer_data = malloc(new_size);
            buffer_max_size = new_size;
        }
        if(new_size) {
            imported_webrogue_gfx_poll_read(buffer_data);
        }
        buffer_used_size = new_size;
        buffer_consumed = 0;
        available = new_size;
    }
    if(available < 4) {
        buffer_consumed = buffer_used_size;
        result.type = WEBROGUE_EVENT_TYPE_INVALID;
        return result;
    }
    const char* current_pointer = ((const char*)buffer_data) + buffer_consumed;
    result.type = GET(uint32_t, 0);
    switch (result.type) {
        case WEBROGUE_EVENT_TYPE_MOUSE_BUTTON: {
            BUF_SIZE(20);
            result.inner.mouse_button.button = GET(uint32_t, 4);
            result.inner.mouse_button.down = GET(uint8_t, 16);
            result.inner.mouse_button.x = GET(uint32_t, 8);
            result.inner.mouse_button.y = GET(uint32_t, 12);
            return result;
        }
        case WEBROGUE_EVENT_TYPE_MOUSE_MOTION: {
            BUF_SIZE(12);
            result.inner.mouse_motion.x = GET(uint32_t, 4);
            result.inner.mouse_motion.y = GET(uint32_t, 8);
            return result;
        }
        case WEBROGUE_EVENT_TYPE_KEY: {
            BUF_SIZE(12);
            result.inner.key.down = GET(uint8_t, 8);
            result.inner.key.scancode = GET(uint32_t, 4);
            return result;
        }
        case WEBROGUE_EVENT_TYPE_QUIT: {
            return result;
        }
        case WEBROGUE_EVENT_TYPE_WINDOW_RESIZED: {
            return result;
        }
        case WEBROGUE_EVENT_TYPE_GL_RESIZED: {
            return result;
        }
        default: {
            buffer_consumed = buffer_used_size;
            result.type = WEBROGUE_EVENT_TYPE_INVALID;
            return result;
        }
    }
}
